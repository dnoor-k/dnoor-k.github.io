# -*- coding: utf-8 -*-
"""topo_validation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FwVif5wE2XCq5cyt2YlcpNAostAD8pFR
"""



#====================
#Setup/Configuration
#=====================

import geopandas as gpd
import pandas as pd

!pip install 'pandera[pandas]'
import pandera as pa
from shapely import wkt
import matplotlib.pyplot as plt
import folium
from shapely.validation import explain_validity
import numpy as np
import warnings

from google.colab import drive
drive.mount('/content/drive')

#Defining Data Contents
COLUMNS = ['objectid', #Record ID
           'parcelid', # Parcel Description
           'tencode', #ten digit code
           'address',
           'owner1',
           'owner2',
           'bldg_code',#Building Classification/Type
           'bldg_desc', #Building Description
           'brt_id', #Property Tax ID
           'num_brt', #BRT accounts per parcel
           'num_accounts', #Accounts prt property record
           'gross_area', #Total Square Feet
           'pin', #ID number
           'parcel_id',
           'Shape__Area', #Sq Feet Area
           'Shape__Length', #Sq Feet Perimeter
           'geometry'] #spatial data

#Reasonable Bounds
DOMAIN_BOUNDS = {
    'gross_area': (100, 50000),          # sq ft
    'Shape__Area': (50, 100000),         # sq units
    'Shape__Length': (10, 2000),         # linear units
    'pin': (1_000_000_000, 9_999_999_999),  # 10-digit PIN
    'num_accounts': (0, 5),              # Accounts per parcel
    'num_brt': (0, 3),                   # BRT accounts per parcel
}

#Expected Data Types per Column

EXPECTED_TYPES = {
    'objectid': 'int64',
    'parcelid': 'object',
    'tencode': 'object',
    'address': 'object',
    'owner1': 'object',
    'owner2': 'object',
    'bldg_code': 'object',
    'bldg_desc': 'object',
    'brt_id': 'object',
    'num_brt': 'int64',
    'num_accounts': 'int64',
    'gross_area': 'float64',
    'pin': 'int64',
    'parcel_id': 'object',
    'Shape__Area': 'float64',
    'Shape__Length': 'float64',
    'geometry': 'geometry'
}
#Data Path
file_path = '/content/drive/MyDrive/c.launch/PWD_PARCELS.geojson'

#Read GeoJSON
gdf = gpd.read_file('/content/drive/MyDrive/c.launch/PWD_PARCELS.geojson')
display(gdf)


#=======================
#Reprojection/Visualization
#=======================

#Create projction data dictionary
projection_info = {
    'original_crs': str(gdf.crs),
    'target_crs': 'EPSG:32618',  # UTM Zone 18N for Philadelphia
    'units': 'meters'}


#Reprojection - Make Proj Local
gdf_metric = gdf.to_crs(projection_info['target_crs'])

#==========================
#Polygon Topology Validation
##Check for Overlaps, Slivers, and Intersections
###sample every 60th polygon/1k polygons (dataset has 547k) to save RAM
#==========================
def check_polygon_topology_fast(gdf, sample_interval=1, max_parcels=None):
    """Optimized topology check using spatial index - ALL PARCELS VERSION"""
    import pandas as pd

    topology_issues = []

    # Filter valid geometries
    valid_gdf = gdf[gdf['geometry'].notna() & ~gdf['geometry'].is_empty].copy()

    # Sample (or use all if sample_interval=1)
    sampled_gdf = valid_gdf.iloc[::sample_interval].copy()

    # Apply max_parcels limit if specified
    if max_parcels is not None and len(sampled_gdf) > max_parcels:
        sampled_gdf = sampled_gdf.iloc[:max_parcels]
        print(f" Limited to {max_parcels} parcels (dataset has {len(valid_gdf)})")

    # Reset index
    sampled_gdf = sampled_gdf.reset_index(drop=True)

    total_parcels = len(sampled_gdf)
    print(f" Checking topology for {total_parcels:,} parcels...")
    print(f"⏱ Estimated time: {total_parcels * 0.002 / 60:.1f} - {total_parcels * 0.005 / 60:.1f} minutes")

    # Build spatial index
    sindex = sampled_gdf.sindex

    checked_pairs = set()

    for idx in range(len(sampled_gdf)):
        row_i = sampled_gdf.iloc[idx]
        geom_i = row_i['geometry']

        if not geom_i.is_valid:
            continue

        # Query spatial index for nearby parcels only
        possible_matches_idx = list(sindex.intersection(geom_i.bounds))

        for idx_j in possible_matches_idx:
            if idx == idx_j:
                continue

            # Skip if already checked this pair
            pair = tuple(sorted([idx, idx_j]))
            if pair in checked_pairs:
                continue
            checked_pairs.add(pair)

            row_j = sampled_gdf.iloc[idx_j]
            geom_j = row_j['geometry']

            if not geom_j.is_valid:
                continue

            # OVERLAP CHECK
            try:
                if geom_i.overlaps(geom_j):
                    intersection_area = geom_i.intersection(geom_j).area
                    topology_issues.append({
                        'issue_type': 'overlap',
                        'parcel_1': row_i.get('parcelid', f'idx_{idx}'),
                        'parcel_2': row_j.get('parcelid', f'idx_{idx_j}'),
                        'index_1': idx,
                        'index_2': idx_j,
                        'area': intersection_area
                    })
                    continue
            except:
                continue

            # SLIVER CHECK
            try:
                if geom_i.touches(geom_j):
                    distance = geom_i.distance(geom_j)
                    if 0 < distance < 0.1:
                        topology_issues.append({
                            'issue_type': 'sliver',
                            'parcel_1': row_i.get('parcelid', f'idx_{idx}'),
                            'parcel_2': row_j.get('parcelid', f'idx_{idx_j}'),
                            'index_1': idx,
                            'index_2': idx_j,
                            'distance': distance
                        })
                        continue
            except:
                continue

            # INTERSECTION CHECK
            try:
                if geom_i.intersects(geom_j):
                    intersection = geom_i.intersection(geom_j)
                    if hasattr(intersection, 'area') and intersection.area > 0:
                        topology_issues.append({
                            'issue_type': 'intersection',
                            'parcel_1': row_i.get('parcelid', f'idx_{idx}'),
                            'parcel_2': row_j.get('parcelid', f'idx_{idx_j}'),
                            'index_1': idx,
                            'index_2': idx_j,
                            'area': intersection.area
                        })
            except:
                continue

        # Progress updates
        if (idx + 1) % 1000 == 0:
            elapsed_pct = ((idx + 1) / total_parcels) * 100
            print(f" {idx + 1:,}/{total_parcels:,} ({elapsed_pct:.1f}%) - {len(topology_issues)} issues found")

    print(f"\n Completed! Total issues found: {len(topology_issues)}")

    # Always return DataFrame
    if len(topology_issues) == 0:
        return pd.DataFrame(columns=['issue_type', 'parcel_1', 'parcel_2', 'index_1', 'index_2', 'area', 'distance'])

    return pd.DataFrame(topology_issues)


# ====================================
# RUN ON ENTIRE DATASET (ALL 547K PARCELS)
# ========================================

print(" Running topology check on ENTIRE dataset...")
print(f" Total parcels in dataset: {len(gdf_metric):,}")

topology_report_full = check_polygon_topology_fast(
    gdf_metric,
    sample_interval=1,      # Check EVERY parcel
    max_parcels=None        # No limit - check ALL
)

# RESULTS
print(f"\n FINAL REPORT")
print(f"=" * 50)
print(f"Dataset: {len(gdf_metric):,} parcels")
print(f"Issues found: {len(topology_report_full):,}")

if len(topology_report_full) > 0:
    print(f"\n Issue breakdown:")
    print(topology_report_full['issue_type'].value_counts())

    print(f"\n Top 20 issues by area:")
    if 'area' in topology_report_full.columns:
        top_issues = topology_report_full.nlargest(20, 'area')
        display(top_issues)
    else:
        display(topology_report_full.head(20))

    # Save to CSV
    output_path = '/content/drive/MyDrive/topology_issues_full.csv'
    topology_report_full.to_csv(output_path, index=False)
    print(f"\n Full report saved to: {output_path}")
else:
    print("\n No topology issues detected in entire dataset!")

#===========================
#Visualize Topology Issues
#==========================

def visualize_topology_issues(gdf, topology_report):
    """
    Create interactive map showing all topology issues using Folium
    """

    if len(topology_report) == 0:
        print("No topology issues to visualize")
        return None

    # Reproject to WGS84 for web mapping
    print("Reprojecting to WGS84...")
    gdf_wgs84 = gdf.to_crs('EPSG:4326')

    print(f"Mapping {len(topology_report)} topology issues")

    # Get all issue indices first
    issue_indices = set()
    for _, issue in topology_report.iterrows():
        issue_indices.add(issue['index_1'])
        issue_indices.add(issue['index_2'])

    # Filter to only parcels with issues
    issue_parcels = gdf_wgs84.iloc[list(issue_indices)]

    # Calculate center from issue parcels
    bounds = issue_parcels.total_bounds  # [minx, miny, maxx, maxy]
    center_lat = (bounds[1] + bounds[3]) / 2
    center_lon = (bounds[0] + bounds[2]) / 2

    print(f"Map center: {center_lat}, {center_lon}")

    # Create base map
    m = folium.Map(
        location=[center_lat, center_lon],
        zoom_start=13,
        tiles='OpenStreetMap'
    )

    # Color scheme
    issue_colors = {
        'overlap': '#FF4444',
        'sliver': '#FFA500',
        'intersection': '#FFFF00'
    }

    # Track how many geometries we actually add
    added_count = 0

    # Add issues to map
    for idx, issue in topology_report.iterrows():
        issue_type = issue['issue_type']
        idx1, idx2 = int(issue['index_1']), int(issue['index_2'])

        # Get geometries
        try:
            row1 = gdf_wgs84.iloc[idx1]
            row2 = gdf_wgs84.iloc[idx2]
            geom1 = row1.geometry
            geom2 = row2.geometry
        except:
            continue

        # Skip invalid geometries
        if geom1 is None or geom2 is None or geom1.is_empty or geom2.is_empty:
            continue

        color = issue_colors.get(issue_type, '#888888')

        # Popup text
        popup_text = f"""
        <b>Issue:</b> {issue_type.upper()}<br>
        <b>Parcel 1:</b> {issue.get('parcel_1', idx1)}<br>
        <b>Parcel 2:</b> {issue.get('parcel_2', idx2)}<br>
        """

        if 'area' in issue and pd.notna(issue['area']):
            popup_text += f"<b>Area:</b> {issue['area']:.2f} m²<br>"
        if 'distance' in issue and pd.notna(issue['distance']):
            popup_text += f"<b>Distance:</b> {issue['distance']:.2f} m<br>"

        # Convert to GeoJSON and add to map
        try:
            # Parcel 1
            folium.GeoJson(
                geom1.__geo_interface__,
                style_function=lambda x, c=color: {
                    'fillColor': c,
                    'color': c,
                    'weight': 2,
                    'fillOpacity': 0.5,
                    'opacity': 0.8
                },
                popup=folium.Popup(popup_text, max_width=300)
            ).add_to(m)

            # Parcel 2
            folium.GeoJson(
                geom2.__geo_interface__,
                style_function=lambda x, c=color: {
                    'fillColor': c,
                    'color': c,
                    'weight': 2,
                    'fillOpacity': 0.5,
                    'opacity': 0.8
                },
                popup=folium.Popup(popup_text, max_width=300)
            ).add_to(m)

            added_count += 2
        except Exception as e:
            print(f"Failed to add geometries for issue {idx}: {e}")
            continue

        # Progress indicator
        if (idx + 1) % 100 == 0:
            print(f"Processed {idx + 1}/{len(topology_report)} issues")

    print(f"Added {added_count} geometries to map")

    # Legend
    legend_html = f'''
    <div style="position: fixed;
                bottom: 50px; right: 50px;
                background-color: white;
                border:2px solid grey;
                z-index:9999;
                padding: 10px;
                font-size:14px">
        <p><b>Topology Issues</b></p>
        <p><span style="color: {issue_colors['overlap']}">■</span> Overlap ({len(topology_report[topology_report['issue_type']=='overlap'])})</p>
        <p><span style="color: {issue_colors['sliver']}">■</span> Sliver ({len(topology_report[topology_report['issue_type']=='sliver'])})</p>
        <p><span style="color: {issue_colors['intersection']}">■</span> Intersection ({len(topology_report[topology_report['issue_type']=='intersection'])})</p>
        <p style="font-size:12px; color:grey;">
            Total: {len(topology_report)} issues
        </p>
    </div>
    '''
    m.get_root().html.add_child(folium.Element(legend_html))

    print("Map created")
    return m


# Run it
if len(topology_report_full) > 0:
    print("\nCreating map...")
    issue_map = visualize_topology_issues(gdf_metric, topology_report_full)

    if issue_map:
        map_path = '/content/drive/MyDrive/topology_issues_map.html'
        issue_map.save(map_path)
        print(f"Saved: {map_path}")
        display(issue_map)

# Simple map visualization
if len(topology_report_full) > 0:

    # Reproject to lat/lon
    gdf_map = gdf_metric.to_crs('EPSG:4326')

    # Get center of Philadelphia
    center = [39.9526, -75.1652]

    # Create map
    m = folium.Map(location=center, zoom_start=12)

    # Sample first 200 issues
    sample = topology_report_full.head(200)

    print(f"Mapping {len(sample)} issues")

    # Add each issue
    for _, row in sample.iterrows():

        i1 = int(row['index_1'])
        i2 = int(row['index_2'])

        # Get geometries
        g1 = gdf_map.iloc[i1].geometry
        g2 = gdf_map.iloc[i2].geometry

        # Skip if bad
        if not g1 or not g2:
            continue

        # Color by type
        if row['issue_type'] == 'overlap':
            color = 'red'
        elif row['issue_type'] == 'sliver':
            color = 'orange'
        else:
            color = 'yellow'

        # Add to map
        folium.GeoJson(g1, style_function=lambda x, c=color: {'color': c, 'fillColor': c, 'fillOpacity': 0.4}).add_to(m)
        folium.GeoJson(g2, style_function=lambda x, c=color: {'color': c, 'fillColor': c, 'fillOpacity': 0.4}).add_to(m)

    # Save
    m.save('/content/drive/MyDrive/issues_map.html')
    print("Map saved")
    display(m)